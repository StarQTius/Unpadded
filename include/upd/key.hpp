//! \file

#pragma once

#include <type_traits>

#include "action.hpp"
#include "detail/io/immediate_reader.hpp"
#include "detail/serialized_message.hpp"
#include "detail/static_error.hpp"
#include "detail/type_traits/remove_cv_ref.hpp"
#include "detail/type_traits/require.hpp"
#include "detail/type_traits/signature.hpp"
#include "format.hpp"
#include "tuple.hpp"
#include "unevaluated.hpp"

#include "detail/def.hpp"

namespace upd {

template<typename Index_T, Index_T Index, typename F, endianess Endianess, signed_mode Signed_Mode>
class key : public key<Index_T, Index, detail::signature_t<F>, Endianess, Signed_Mode> {
  static_assert(detail::is_invocable<F>::value, UPD_ERROR_NOT_INVOCABLE(F));
};

//! \brief Packet generator for invoking an action on a slave device
//!
//! Keys will generate packets whose structure is the following:
//!   - index of the action (value: `Index`; size: `sizeof Index`);
//!   - payload (size: `sizeof(Args) + ...`);
//!
//! The index is used by the slave to determine which action is addressed (see `dispatcher`). The content of the payload
//! is choosen by the user. In the following example \code int function1(uint8_t, uint16_t); int function2(uint16_t,
//! uint32_t); int function3(uint32_t, uint64_t);
//!
//! constexpr keyring keyring{flist<function1, function2, function3>};
//!
//! int main() {
//!   auto key = keyring.get<function2>();
//!   key(7, 21) >> /*an output invocable*/;
//! }
//! \endcode
//! the packet sent will have the following content:
//!   - 1 byte of index (value: 1)
//!   - 2 bytes for the first argument of `function2` (type: `uint16_t`; value: 7)
//!   - 4 bytes for the second argument of `function2` (type: `uint32_t`; value: 21)
//!
//! When the packet has been processed by the slave device and the resulting value is sent back to the master device,
//! keys can be used to extract this value from the slave response. The syntax to achieve that is `auto x = key << /*an
//! input invocable*/`. However, key instances being templated, it is hard to store them for later. If blocking the
//! program until the slave device response is not a viable option, it is possible to save a callback to be executed
//! once the slave device has finished using the `ticket` class.
//!
//! \tparam Index Index of the action in the keyring
//! \tparam F Signature of the invocable associated with the key
//! \tparam Endianess Byte order of the integers in the generated packets
//! \tparam Signed_Mode Representation of signed integers in the generated packets
#if defined(DOXYGEN)
template<typename Index_T, Index_T Index, typename F, endianess Endianess, signed_mode Signed_Mode>
class key
#else  // defined(DOXYGEN)
template<typename Index_T, Index_T Index, typename R, typename... Args, endianess Endianess, signed_mode Signed_Mode>
class key<Index_T, Index, R(Args...), Endianess, Signed_Mode>
    : public detail::immediate_reader<key<Index_T, Index, R(Args...), Endianess, Signed_Mode>,
                                      detail::remove_cv_ref_t<R>>
#endif // defined(DOXYGEN)
{
public:
  //! \brief Type of the index as found in the packets generated by this key
  using index_t = Index_T;

  //! \brief Signature of the invocable associated with this key
  using signature_t = R(Args...);

  //! \brief Return type of `read_from`(i.e. the return type of the invocable without its reference and cv-qualifier)
  using return_t = detail::remove_cv_ref_t<R>;

  //! \brief Type of the tuple which can be invoked on this key (like so for example: `t.invoke(key)`)
  using tuple_t = tuple<Endianess, Signed_Mode, detail::remove_cv_ref_t<Args>...>;

  //! \brief Equals the `Index` template parameter
  constexpr static auto index = Index;

  //! \brief Equals the `Endianess` template parameter
  constexpr static auto endianess = Endianess;

  //! \brief Equals the `Signed_Mode` template parameter
  constexpr static auto signed_mode = Signed_Mode;

  //! \brief Equals the length in bytes of an action request produced by this key
  constexpr static auto payload_length = sizeof(Index_T) + detail::parameters_size<R(Args...)>::value;

  //! \brief Generate a packet ready to be sent
  //!
  //! This allows the following syntax : `key(x1, x2, x3, ...) >> dest` (with `dest` being an output invocable).
  //! `dest_f` is invoked on every byte representing the data passed as parameter, in the action they appear in the
  //! packet.
  //!
  //! \param args... Values to insert in the payload
  //! \return a temporary object allowing the syntax mentioned above
#if defined(DOXYGEN)
  auto operator()(const Args &...args) const;
#else  // defined(DOXYGEN)
  detail::serialized_message<Endianess, Signed_Mode, Index_T, detail::remove_cv_ref_t<Args>...>
  operator()(const Args &...args) const {
    return {Index, args...};
  }
#endif // defined(DOXYGEN)

  using detail::immediate_reader<key<Index_T, Index, R(Args...), Endianess, Signed_Mode>, return_t>::read_from;

  //! \brief Unserialize a value from a packet sent by a slave device in response to a packet generated by this key
  //! \copydoc ImmediateReader_CRTP
  //!
  //! \param src Input invocable to the packet
  //! \return the unserialized value
  template<typename Src, REQUIREMENT(input_invocable, Src), REQUIRE_CLASS(!std::is_void<return_t>::value)>
  return_t read_from(Src &&src) const {
    tuple<Endianess, Signed_Mode, detail::remove_cv_ref_t<R>> retval;
    for (auto &byte : retval)
      byte = FWD(src)();

    return retval.template get<0>();
  }

  //! \copydoc read_from
  template<typename Src, REQUIREMENT(input_invocable, Src), REQUIRE_CLASS(std::is_void<return_t>::value)>
  void read_from(Src &&) const {}

  UPD_SFINAE_FAILURE_MEMBER(read_from, UPD_ERROR_NOT_INPUT(src))

  //! \brief Plan an action to perform when a packet resulting from the execution of the action is received
  //! \param ftor Callback which will carry out the action
  //! \return an action holding the provided hook
  template<typename F, REQUIREMENT(invocable, F)>
  action with_hook(F &&ftor) const {
    return action{FWD(ftor), endianess_h<Endianess>{}, signed_mode_h<Signed_Mode>{}};
  }

  //! \copybrief with_hook
  //! \tparam Ftor Callback which will carry out the action
  //! \return an action holding the provided hook
  template<typename F, F Ftor, REQUIREMENT(invocable, F)>
  no_storage_action with_hook(unevaluated<F, Ftor>) const {
    return no_storage_action{unevaluated<F, Ftor>{}, endianess_h<Endianess>{}, signed_mode_h<Signed_Mode>{}};
  }

#if __cplusplus >= 201703L
  //! \copybrief with_hook
  //! \tparam Ftor Callback which will carry out the action
  //! \return an action holding the provided hook
  template<auto &Ftor, REQUIREMENT(invocable, decltype(Ftor))>
  auto with_hook() const {
    return with_hook(unevaluated<decltype(Ftor), Ftor>{});
  }
#endif // __cplusplus >= 201703L

  UPD_SFINAE_FAILURE_MEMBER(with_hook, UPD_ERROR_NOT_INVOCABLE(F))
};

template<typename Index_T, Index_T Index, endianess Endianess, signed_mode Signed_Mode>
class key<Index_T, Index, detail::no_signature, Endianess, Signed_Mode> {};

#include "detail/undef.hpp" // IWYU pragma: keep

} // namespace upd
