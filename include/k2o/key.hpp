//! \file

#pragma once

#include <upd/format.hpp>
#include <upd/tuple.hpp>

#include "detail/io/immediate_reader.hpp"
#include "detail/serialized_message.hpp"
#include "detail/static_error.hpp"
#include "detail/type_traits/remove_cv_ref.hpp"
#include "detail/type_traits/require.hpp"
#include "detail/type_traits/signature.hpp"
#include "ticket.hpp"

#include "detail/def.hpp"

namespace k2o {

template<typename Index_T, Index_T Index, typename F, upd::endianess Endianess, upd::signed_mode Signed_Mode>
class key : public key<Index_T, Index, detail::signature_t<F>, Endianess, Signed_Mode> {
  static_assert(detail::is_invocable<F>::value, K2O_ERROR_NOT_INVOCABLE(F));
};

//! \brief Packet generator for invoking an order on a slave device
//!
//! Keys will generate packets whose structure is the following:
//!   - index of the order (value: `Index`; size: `sizeof Index`);
//!   - payload (size: `sizeof(Args) + ...`);
//!
//! The index is used by the slave to determine which order is addressed (see `dispatcher`). The content of the payload
//! is choosen by the user. In the following example \code int function1(uint8_t, uint16_t); int function2(uint16_t,
//! uint32_t); int function3(uint32_t, uint64_t);
//!
//! constexpr k2o::keyring keyring{k2o::flist<function1, function2, function3>};
//!
//! int main() {
//!   auto key = keyring.get<function2>();
//!   key(7, 21) >> /*an output invocable*/;
//! }
//! \endcode
//! the packet sent will have the following content:
//!   - 1 byte of index (value: 1)
//!   - 2 bytes for the first argument of `function2` (type: `uint16_t`; value: 7)
//!   - 4 bytes for the second argument of `function2` (type: `uint32_t`; value: 21)
//!
//! When the packet has been processed by the slave device and the resulting value is sent back to the master device,
//! keys can be used to extract this value from the slave response. The syntax to achieve that is `auto x = key << /*an
//! input invocable*/`. However, key instances being templated, it is hard to store them for later. If blocking the
//! program until the slave device response is not a viable option, it is possible to save a callback to be executed
//! once the slave device has finished using the `ticket` class.
//!
//! \tparam Index Index of the order in the keyring
//! \tparam F Signature of the invocable associated with the key
//! \tparam Endianess Byte order of the integers in the generated packets
//! \tparam Signed_Mode Representation of signed integers in the generated packets
#if defined(DOXYGEN)
template<typename Index_T, Index_T Index, typename F, upd::endianess Endianess, upd::signed_mode Signed_Mode>
class key
#else  // defined(DOXYGEN)
template<typename Index_T,
         Index_T Index,
         typename R,
         typename... Args,
         upd::endianess Endianess,
         upd::signed_mode Signed_Mode>
class key<Index_T, Index, R(Args...), Endianess, Signed_Mode>
    : public detail::immediate_reader<key<Index_T, Index, R(Args...), Endianess, Signed_Mode>,
                                      detail::remove_cv_ref_t<R>>
#endif // defined(DOXYGEN)
{
public:
  //! \brief Type of the index as found in the packets generated by this key
  using index_t = Index_T;

  //! \brief Signature of the invocable associated with this key
  using signature_t = R(Args...);

  //! \brief Return type of `read_all`(i.e. the return type of the invocable without its reference and cv-qualifier)
  using return_t = detail::remove_cv_ref_t<R>;

  //! \brief Type of the tuple which can be invoked on this key (like so for example: `t.invoke(key)`)
  using tuple_t = upd::tuple<Endianess, Signed_Mode, detail::remove_cv_ref_t<Args>...>;

  //! \brief Equals the `Index` template parameter
  constexpr static auto index = Index;

  //! \brief Equals the `Endianess` template parameter
  constexpr static auto endianess = Endianess;

  //! \brief Equals the `Signed_Mode` template parameter
  constexpr static auto signed_mode = Signed_Mode;

  //! \brief Generate a packet ready to be sent
  //!
  //! This allows the following syntax : `key(x1, x2, x3, ...) >> dest` (with `dest` being an output invocable).
  //! `dest_f` is invoked on every byte representing the data passed as parameter, in the order they appear in the
  //! packet.
  //!
  //! \param args... Values to insert in the payload
  //! \return a temporary object allowing the syntax mentioned above
#if defined(DOXYGEN)
  auto operator()(const Args &...args) const;
#else  // defined(DOXYGEN)
  detail::serialized_message<Endianess, Signed_Mode, Index_T, detail::remove_cv_ref_t<Args>...>
  operator()(const Args &...args) const {
    return {Index, args...};
  }
#endif // defined(DOXYGEN)

  using detail::immediate_reader<key<Index_T, Index, R(Args...), Endianess, Signed_Mode>, return_t>::read_all;

  //! \brief Unserialize a value from a packet sent by a slave device in response to a packet generated by this key
  //! \copydoc ImmediateReader_CRTP
  //!
  //! \param src Input invocable to the packet
  //! \return the unserialized value
  template<typename Src, REQUIREMENT(input_invocable, Src)>
  return_t read_all(Src &&src) const {
    upd::tuple<Endianess, Signed_Mode, detail::remove_cv_ref_t<R>> retval;
    for (auto &byte : retval)
      byte = FWD(src)();

    return retval.template get<0>();
  }

  K2O_SFINAE_FAILURE_MEMBER(read_all, K2O_ERROR_NOT_INPUT(src))

  //! \brief Plan an action to perform when a packet resulting from the execution of the order is received
  //!
  //! \param hook Callback which will carry out the action
  //! \return a ticket holding the provided hook
  template<typename F, REQUIRE(detail::is_invocable<F>::value)>
  ticket with_hook(F &&hook) {
    return ticket{FWD(hook), *this};
  }

  K2O_SFINAE_FAILURE_MEMBER(with_hook, K2O_ERROR_NOT_INVOCABLE(hook))
};

template<typename Index_T, Index_T Index, upd::endianess Endianess, upd::signed_mode Signed_Mode>
class key<Index_T, Index, detail::no_signature, Endianess, Signed_Mode> {};

#include "detail/undef.hpp" // IWYU pragma: keep

} // namespace k2o
